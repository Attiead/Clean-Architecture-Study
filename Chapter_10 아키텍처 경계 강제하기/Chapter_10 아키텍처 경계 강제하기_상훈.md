##### Intro
* 일정 시간이 지나면서 아키텍처가 서서히 무너지게 됨
  * 계층 간 경계 약화, 테스트의 어려움, 새로운 기능 추가 시 더 많은 시간이 듬
* 이번 장에서는 아키텍처 내의 경계를 강제하는 방법과 아키텍처 붕괴에 맞서 싸우기 위해 취할 수 있는 몇 가지 조치
##### 경계와 의존성
* 도메인 계층 : 가장 안쪽
* 애플리케이션 계층 : 애플리케이션 서비스안에 유스케이스를 구현하기 위해 도메인 엔티티에 접근
* 어댑터 : 인커밍 포트를 통해 서비스 접근
* 서비스 : 아웃커밍 포트를 통해 어댑터에 접근
* 설정 계층 : 어뎁터와 서비스 객체를 생성할 팩터리를 포함, 의존성 주입 메커니즘을 제공
* 위와 같은 의존성 규칙을 강제하는 방법들을 알아보고 잘못된 방향을 가리키는 의존성을 없게 만들고자 함
##### 접근 제한자
* 자바에서 제공하는 가장 기본적인 도구를 통해 경계를 강제
* default 제한자
  * 자바 패키지를 통해 클래스들을 응집적인 '모듈'로 만들어준다. -> 모듈 내에 있는 클래스들은 서로 접근이 가능 
  * 패키지 바깥에서는 접근할 수 없기 때문에 모듈의 진입점으로 활용될 클래스들만 골라서 public으로 만들면 됨.
  * 
##### 컴파일 후 체크

##### 빌드 아티팩트
* 빌드 도구의 주요한 기능 중 하나는 의존성 해결
  * 코드베이스를 빌드 아티팩트로 변환하려면...
    * 코드베이스가 의존하고 있는 모든 아티팩트가 사용 가능한지 확인, 없으면 아티팩트 리포지토리에서 가져오려고 시도, 이마저도 실패하면 컴파일도 하기 전에 에러와 함께 빌드 실패
  * 위 과정을 활용해 모듈과 아키텍처의 계층 간의 의존성을 강제할 수 있다. (부수적으로 경계를 강제하는 효과도 얻음.)
    * 각 모듈 혹은 계층에 대해 전용 코드베이스와 빌드 아티팩트로 분리된 빌드 모듈을 만듦
    * 각 모듈의 빌드 스크립트에서는 아키텍처에서 허용하는 의존성만 지정
    * ex. 설정, 어댑터, 애플리케이션 계층의 빌드 아티팩트로 이루어진 3개의 모듈 빌드 방식
      * 

##### 정리
* 소프트웨어 아키텍어는 아키텍어 요소 간의 의존성을 관리하는게 전부
* 의존성이 거대한 진흙 덩어리가 되면 아키텍처 역시 거대한 진흙 덩어리가 (뚜렷한 아키텍처가 없게)됨
* 그렇기 때문에 지속적인 의존성 확인이 필요
  * 새로운 코드를 추가하거나 리팩터링할 때 패키지 구조를 항상 염두
  * 가능하다면 package-private 가시성을 이용해 패키지 바깥에서 접근하면 안되는 클래스에 대한 의존성을 피해야 함
  * 하나의 빌드 모듈 안에서 아키텍처 경계를 강제해야 하고, 패키지 구조가 허용하지 않아 package-private 제한자를 사용할 수 없다면 ArchUnit 같은 컴파일 후 체크 도구를 이용해야 한다.
* 아키텍처가 충분히 안정적이라고 느껴지면 아키텍처 요소를 독립적인 빌드 모듈로 추출해야 한다 -> 의존성을 분명하게 제어할 수 있기 때문
* 