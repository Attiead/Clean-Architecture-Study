##### 단일 책임 원칙
* 일반적인 해석 
  <br>하나의 컴포넌트는 오로지 한 가지  일만 해야 하고, 그것을 올바르게 수행해야 한다.
* 실제 정의
  > 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.
    * 책임 : `오로지 한 가지 일만 하는 것` 보다는 `변경할 이유`로 해석해야 한다.
* 이것은 어떤 변경사힝이 발생해도 이 컴포넌트의 변경할 이유와는 상관 없기에(하나이기까) 여전히 우리가 기대한 대로 동작할 것이다.
* but 컴포넌트 간 의존성을 통해 너무도 쉽게 전파됨 -> 시간이 지날 수록 더 문제
##### 부수효과에 관한 이야기
* 컴포넌트 변경에 따른 부수효과를 걱정하여 효율적이지 못한 방식으로 기능을 추가하게 되는 문제가 발생하게 된다.
##### 의존성 역전 원칙
* 아래 방향을 가리키는 계층 간 의존때문에 영속성 계층에 의존하고 있던 도메인 계층이 영속성 계층의 변경으로 인해 잠재적으로 도메인 코드가 변경됨
###### 이 의존성을 제거할 방법은?
* 의존성 역전 원칙(Dependency Inversion Principle, DIP)
  > 코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수)있다.
  > * 양 쪽 코드를 모두 제어할 수 있을 때 가능.
* 엔티티는 도메인 객체를 표현하고, 도메인 코드는 이 엔티티들의 상태를 변경하는 일을 하기 때문에 먼저 엔티티를 도메인 계층으로 올림
* 다음 영속성 계층의 리포지터리가 도메인 계층에 있는 엔티티에 의존하기 때문에 두 계층 사이에 순환 의존성이 생긴다. 
* 이 부분에서 DIP를 적용
* 도메인 계층에 리포지터리를 만들고 실제 리포지토리는 영속성 계층에서 구현하게 되는 것.
##### 클린 아키텍처
* 클린 아키텍처
  * 설계가 비즈니스 규칙의 테스트를 용이하게 
  * 비즈니스 규칙은 프레임웤, 데이터베이스 UI기술등으로부터 독립적일 수 있다
  * 이것은 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 함
  * 의존성 역전 원칙의 도움으로 모든 의존성이 도메인 코드(엔티티)를 향하고 있다.

##### 육각형 아키텍처(헥사고날 아키텍처)

##### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?