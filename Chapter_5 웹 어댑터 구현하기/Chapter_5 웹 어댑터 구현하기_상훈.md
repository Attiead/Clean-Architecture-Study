##### Intro
> 웹 인터페이스
* 상호작용하는 HTTP API
* 우리가 목표로 하는 아키텍처에서 외부 세계와의 모든 커뮤니케이션은 어댑터를 통해 이뤄진다
* 어댑터 구현 방법을 살펴보자

##### 의존성 역전
* 인커밍 어댑터 
* 애플리케이션 서비스에 의해 구현된 인터페이스인 전용 포트를 통해 애플리케이션 계층과 통신한다.
* 흐름 : 외부로부터 요청을 받아 애플리케이션 코어를 호출하고 무슨 일을 해야 할지 알려준다.(웹 어댑터의 '컨트롤러' -> 애플리케이션 계층의 '서비스')
* 웹 어댑터는 포트를 호출하는데, 호출된 포트(인터페이스)를 구현한 서비스(구현체)가 있다. -> 의존성 역전 원칙이 적용
* 간접 계층(포트) : 애플리케이션 코아가 외부 세계와 통신할 수 잇는 곳에 대한 '명세'
> 애플리케이션 코어에서는 실시간 데이터를 어떻게 웹 어댑터로 보내고, 웹 어댑터는 이 데이터를 어떻게 사용자의 브라우저로 전송하는 것일까?
* 반드시 포트가 필요
* p.55 Q. 만약 애플리케이션이 웹 어댑터에 능동적으로 알림을 줘야 한다면 의존성을 올바른 방향으로 유지하기 위해 아웃고잉 포트를 통과해야 한다?? 통과? 어느 방향으로?
* (의존성의)올바른 방향? (드라이빙 어댑터 --> 유스케이스가 구현한 인커밍 포트 --> 애플리케이션 코어 (유스케이스, 엔티티) -> 드라이븐 어댑터로 구현된 아웃고잉 포트(육각형 그림) -> 그 다름 어디로? 다시 
                                                                                                             -> 웹 소켓 컨트롤러로 구현한 아웃고잉 포트? (p.55 그림) (여기서 웹 소켓 컨트롤러는 adapter - in 에 위치)
* 아! 이 포트는 아웃고잉 포트이기 때문에 웹 어댑터는 인커밍 어댑터인 동시에 아웃고잉 어댑터가 된다.
##### 웹 어댑터의 책임
1. HTTP 요청을 자바 객체로 매핑
2. 권한 검사
3. 입력 유효성 검증
4. 입력을 유스케이스의 입력 모델로 매핑
5. 유스케이스 호출
6. 유스케이스의 출력을 HTTP로 매핑
7. HTTP 응답을 반환
* 입력 유효성 검증
  * 유스케이스 입력 모델 : 유스케이스의 맥락에서 유효한 입력만 허용
  * 웹 어댑터 : 웹 어댑터의 입력 모델을 유스케이스의 입력 모델로 변환할 수 있다는 것을 검증
##### 컨트롤러 나누기
* 한 개 이상의 클래스로 구성 가능. 단, 클래스들이 같은 소속이라는 것을 표현하기 위해 같은 패키지 수준에 놓아야
> *스프링 컨트롤러 
>   * 모든 것이 하나의 클래스에 모여 있음 -> 아래의 단점
>   * 클래스마다 코드는 적을 수로 좋다
>   * 테스트 시에도 어려움 (테스트하고자 하는 코드를 찾기가 어려움)
>   * 데이터 구조의 재활용을 촉진 (쓸모 없는 것까지 사용하게 됨)
>* 그래서 저자는
>  * 별도의 패키지 안에 별도의 컨트롤러를 만드는 방식
>  * 가급적 메서드와 클래스명은 유스케이스를 최대한 반영 
##### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?
1. 웹 어댑터 구현시: HTTP 요청을 애플리케이션의 유스케이스에 대한 메서드 호출로 변환, 다시 HTTP로 변환 -> 어떤 도메인 로직도 수행하지 않는 어댑터를 만들고 있음을 염두
2. 애플리케이션 계층 : HTTP에 대한 상세 정보를 노출시키지 않도록 HTTP와 관련된 작업을 해서는 안됨 -> 필요할 경우 웹 어댑터를 다른 어댑터로 쉽게 교체할 수 있다.
3. 웹 컨트롤러 나눌 때 : 모델을 공유하지 않는 여러 작은 클래스들을 만드는 것을 두려워해서는 안 됨. -> 작은 클래스들은 더 파악하기 쉽고, 테스트도 쉽고, 동시 작업을 지원.