##### Intro
* 육각형 아키텍처에서의 테스트 전략에 대해 살펴보자
* 아키텍처의 각 요소들을 테스트할 수 있는 테스트 유형에 대해 논의
##### 테스트 피라미드
* 테스트 피라미드에 따르면 비용이 많이 드는 테스트는 지양하고 비용이 적게 드는 테스트를 많이 만들어야 한다.
* 단위테스트
  * 일반적으로 하나의 클래스를 인스턴스화하고 해당 클래스의 인터페이스를 통해 기능들을 테스트
  * 테스트 중인 클래스가 다른 클래스를 의존한다면 의존되는 클래스들은 인스턴스화하지 않고 테스트하는 동안 필요한 작업들을 흉내 내는 목(mock)으로 대체한다.
    * Mock 이란? : 실제 객체를 만들어 사용하기에 시간, 비용등의 cost가 높거나 혹은 객체 서로간의 의존성이 강해 구현하기 힘들 경우 가까 잭체를 만들어서 사용하는 방법
    * Mock 객체는 언제 필요한가?
      * 테스트 작성을 위한 환경 구축이 어려운 경우
      * 테스트가 특정 경우나 순간에 의존적인 경우
      * 테스트 시간이 오래 걸리는 경우
      * 개인 PC의 성능이나 서버의 성능문제로 오래 걸릴 수 있는 경우 시간을 단축하기 위해 사용
    * Mock에 대한 기본적인 분류 개념
      * 테스트 더블
        * 테스트를 진행하기 어려운 경우 이를 대신해 테스트를 진행할 수 있도록 만들어주는 객체.
        * Mock 객체와 유사한 의미를 가지며 테스트 더블이 좀더 상위 의미로 사용된다.
      * 더미객체
        * 단순히 인스턴스화 될 수 있는 수준으로만 객체를 구현
        * 인스턴스화된 객체가 필요한 뿐 해당 객체의 기능까지는 필요하지 않은 경우에 사용한다.
      * 테스트 스텁
        * 더미 객체 보다 좀 더 구현된 객체로 더미 객체가 마치 실제로 동작하는 것처럼 보이게 만들어 놓은 객체
        * 객체의 특정 상태를 가정해서 만들어 특정 값을 리턴해 주거나 메시지를 출력해주는 작업을 말한다
        * 특정 상태를 가정해서 하드코딩된 형태이기 때문에 로직에 따른 값의 변경은 테스트 할 수 없다.
        * 즉, 어떤 행위가 호출됐을 때 특정 값으로 리턴시켜주는 형태
      * 페이크 객체
        * 여러 상태를 대표할 수 있도록 구현된 객체로 실제 로직이 구현된 것처럼 보이게 한다.
        * 실제로 DB에 접속해서 비교할 때와 동일한 모양이 보이도록 객체내부에 구현 할 수 있다.
          * 테스트 케이스 작성을 위해서 다른 객체들과의 의존성을 제거하기 위해 사용
          * 페이크 객체를 만들 때 복잡도로 인해서 노력이 많이 들어 갈 경우 적절한 수준에서 구현하거나, Mock 프레임 워크를 사용
          * 페이크 객체를 생성하기 위한 노력이 많이 필요한 경우 실제 객체를 가져와 테스트
      * 테스트 스파이
        * 테스트에 사용되는 객체, 메소드의 사용여부 및 정상 호출 여부를 기록하고 요청시 알려준다.
        * 테스트 더블로 구현된 객체에 자기 자신이 호출 되었을 때 확인이 필요한 부분을 기록하도록 구현한다.
      * Mock 객체
        * 행위를 검증하기 위해 사용되는 객체를 지칭, 수동 혹은 프레임워크로 만들 수 있음
        * 행위 기반 테스트는 복잡도나 정확성등 작성하기 어려운 부분이 많기 때문에 상태 기반 테스트가 가능하다면 만들지 않음
        * Mock 객체는 테스트 더블 하위 객체로 좁은 의미와 테스트 더블을 포함한 넓은 의미 2가지로 사용 될 수 있다.
* 통합 테스트
  * 연결된 여러 유닛을 인스턴스화하고 시작점이 되는 클래스의 인터페이스로 데이터를 보낸 후 유닛들의 네트워크가 기대한 대로 잘 동작하는지 검증
* 시스템 테스트
  * 애플리케이션을 구성하는 모든 객체 네트워크를 가동시켜 특정 유스케이스가 전 계층에서 잘 동작하는지 검증
##### 단위 테스트로 도메인 엔티티 테스트하기
> 특정 상태의 Account를 인스턴스화 / withdraw() 메서드를 호출해서 출금을 성공했는지 검증 
* 위 단위 테스트는 도메인 엔티티에 녹아 있는 비즈니스 규칙을 검증하기에 가장 적절한 방법.
* 도메인 엔티티의 행동은 다른 클래스에 거의 의존하지 않기 때문에 다른 종류의 테스트는 필요햐지 않다.
##### 단위 테스트로 유스케이스 테스트하기
> 테스트할 아키텍처 요소 : 유스케이스
> ex. SendMoneyService
> 1. 출금 계좌의 잔고가 다른 트랜잭션에 의해 변경되지 않도록 락을 건다.
> 2. 출금 계좌에서 돈이 출금되고 나면 똑같이 입금 계좌에 락을 걸고 돈을 입금
> 3. 두 계좌에서 모두 락을 해제
* given/when/then 섹션 
  * 행동-주도 개발(behavior driven development)테스트에서 일반적으로 사용되는 방식
  * 가독성을 높임
    * given : 출금 및 입금 Account의 인스턴스를 각각 생성하고 적절한 상태로 만듬
    * when : 유스케이스를 실행하기 위해 sendMoney() 메서드 호출
    * then : 트랜잭션이 성공적이었는지 확인
* Mockito 라이브러리를 이용
  * given() 메서드 - 목 객체를 생성
  * then() 메서드 - 목 객체에 대한 특정 메서드가 호출됐는지 검증할 수 있음
* 테스트 중인 유스테이스 서비스는 상태가 없음 -> then 섹션에서 특정 상태를 검증할 수 없음 -> 대신 모킹된 의존 대상의 특정 메서드와 상호작용했는지 여부를 검증
> Q. (p.86)
>> 이는 테스트가 코드의 행동 변경 뿐만 아니라 코드의 구조 변경에도 취약해진다는 의미가 된다
> 왜 행동 변경 뿐만 아니라 코드의 구조 변경에도 취약해질까?
* 모든 동작을 검증하는 대신 중요한 핵심만 골라 집중해서 테스트하는 것이 좋다
##### 통합 테스트로 웹 어댑터 테스트하기
> * 웹 어댑터 흐름
>   1. JSON 문자열 등의 형태로 HTTP를 통해 입력을 받음
>   2. 입력에 대한 유효성을 검증
>   3. 유스테이스에서 사용할 수 있는 포맷으로 매핑
>   4. 유스케이스에 전달
>   5. 유스케이스의 결과를 JSON으로 매핑
>   6. HTTP 응답을 통해 클라이언트에 반환
> * 표준적인 통합 테스트 예시
>   * 대상 : SendMoneyController(웹 컨트롤러) 
>   * testSendMoney() 메서드 : 입력 객체를 만들고 목 HTTP 요청을 웹 컨트롤러에 보냄
>   * isOk() 메서드 : HTTP 응답의 상태가 200임을 확인, 모킹한 유스케이스가 잘 호출 됐는지 검증
> * 단위 테스트가 아니라 통합 테스트인 이유
>   * 하나의 웹컨트롤러 클래스만 테스트한 것처럼 보이지만, 보이지 않은 곳에서 더 많은 일들이 벌어지고 있다.
>     * @WebMvcTest 애너테이션 : 스프링이 특정 요청 경로 + 자바와 JSON 간의 매핑 + HTTP 입력 검증 등에 필요한 전체 객체 네트워크를 인스턴스화 하도로 만든다고 함
>   * 웹 컨트롤러가 스프링 프레임워크에 강하게 묶여 있기 때문에 격리된 상태로 테스트하기 보다는 이 프레임워크와 통합된 상태로 테스트 하는 것이 합리적이다라고 함
##### 통합 테스트로 영속성 어댑터 테스트하기
* 영속성 어댑터에 통합 테스트를 적용하는 이유는 단순히 어댑터의 로직만 검증하고 싶은 게 아니라 데이터 베이스 매핑도 검증하고 싶기 때문
> * 예시
>   * 대상 : AccountPersistenceAdapterTest
>   * loadsAccount() : Account 엔티티를 데이터베이스로부터 가져오는 메서드 
>   * updateActivities() : 새로운 계좌 활동을 데이터베이스에 저장하는 메서드
>   * @DataJpaTest : 스프링 데이터 리포지토리들을 포함해서 데이터베이스 접근에 필요한 객체 네트워크를 인스턴스화해야 한다고 스프링에 알려줌
>   * @Import : 특정 객체가 이 네트워크에 추가됐다는 것을 명확하게 표현할 수 있다, 이 객체들은 테스트 상에서 어댑터가 도메인 객체를 데이터베이스 객체로 매핑하는등의 작업에 필요하다
* 이 테스트에서는 데이터베이스를 모킹하지 않았다
  * 모킹을 했다고 해도 테스트는 여전히 같은 코드 라인 수만큼 커버해서 똑같이 높은 커버리지를 보여줬을 것 -> 모킹 하나마나
  * 그럼에도 영속성 어댑터 테스트는 실제 데이터 베이스를 대상으로 진행해야 한다
    * 인메모리 데이터베이스에서 테스트가 통과해도, 실제 데이터베이스에서는 문제가 생길 가능성이 높다
##### 시스템 테스트로 주요 경로 테스트하기
* 전체 애플리케이션을 띄우고 API를 통해 요청을 보내고, 모든 계층이 조화롭게 잘 동작하는지 검증한다.
> * 예시
>   * 대상 : SendMoneySystemTest
>   * @SpringBootTest : 스프링이 애플리케이션을 구성하는 모든 객체 네트워크를 띄우게 함
>   * test 메서드 : 요청을 생성해서 애플리케이션을 띄우도록 설정
>   * TestRestTemplate : 요청을 보냄  / 실제 HTTP 통신을 하기 위해 MockMvc를 이용하지 않음
* 도메인 특화 언어 (domain-specific language, DSL) , 헬퍼 메서드?? 관련 예시가 있을까?
##### 얼마만큼의 테스트가 충분할까?
* 라인 커버리지(테스트 실행시 실행된 라인의 수를 전체 라인 수 대비 퍼센티지) -> 잘못된 지표
* 우리가 만들어야 할 테스트를 정의하는 전략으로 시작하는 것도 좋다
  * 도메인 엔티티를 구현할 때는 단위 테스트로 커버하자
  * 유스케이스를 구현할 때는 단위 테스트로 커버하자
  * 어댑터를 구현할 때는 통합 테스트로 커버하자
  * 사용자가 취할 수 있는 중요 애플리케이션 경로는 시스템 테스트로 커버하자
##### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?
* 테스트 전략을 어떻게?
  * 육각형 아키텍처는 도메인 로직과 바깥으로 향한 어댑터를 깔끔하게 분리한다.
  * 덕분에 핵심 도메인 로직은 단위테스트로, 어댑터는 통합 테스트 
* 모킹
  * 입출력 포트는 테스트에서 아주 뚜렷한 모킹 지점
  * 각 포트에 대해 모킹할지 or 실제 구현을 이용할 지 선택 가능
  * 포트 인터페이스가 더 적은 메서드를 제공할수록 어떤 메서드를 모킹해야 할지 덜 헷갈린다