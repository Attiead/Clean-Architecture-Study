아키텍처 요소 테스트하기
==

테스트 피라미드
--
시스템테스트 - 통합테스트 - 단위 테스트

여러개의 단위와 단위를 넘는 경계, 아키텍처 경계, 시스템 경계를 결합하는 테스트는 만드는 비용이 더 비싸지고, 실행이 더 느려지며 깨지기 쉬워진다.
> 새로운 기능을 만드는 것보다 테스트를 만드는 데 시간을 더 쓰게 되기 때문이다. => 매우 공감.

단위테스트 : <br>
- 일반적으로 하나의 클래스를 인스턴스화하고 해당 클래스의 인터페이스를 통해 기능들을 테스트함.
- 테스트 중인 클래스가 다른 클래스에 의존한다면 의존되는 클래스들은 인스턴스화 하지 않고 테스트하는 동안 필요한 작업들을 mock으로 대체한다.
- e.g) 서비스 테스트

통합테스트 : <br>
- 연결된 여러 유닛을 인스턴스화 하고 유닛들의 네트워크가 기대한 대로 잘 동작하는지 검증.
- 두 계층 간 경계를 걸쳐서 테스트 등.
- e.g) 컨트롤러 테스트

시스템 테스트 : <br>
- UI를 포함한 end-to-end 테스트. 
- e.g) selenium 같은 자동화 테스트 등.


단위 테스트로 도메인 엔티티 테스트
--
도메인 엔티티에 녹아 있는 비즈니스 규칙을 검증하기에 가장 적절한 방법.

단위 테스트로 유스케이스 테스트
--
모든 동작을 검증하는 대신 중요한 핵심만 골라 집중해서 테스트하는 것이 좋다.<br>
-> 클래스가 조금이라도 바뀔 때마다 테스트를 변경해야 하기 때문

통합 테스트로 웹 어댑터 테스트
--
웹 어댑터 : JSON 등의 형태로 HTTP를 통해 입력 받고, 입력에 대한 유효성 검증하고, 유스케이스에서 사용할 수 있는 포맷으로 매핑하고, 유스케이스에 전달, 이후 반환

@WebMvcTest 사용.

통합 테스트로 영속성 어댑터 테스트
--
단순 어댑터의 로직 뿐만 아니라 데이터베이스 매핑도 검증해야 하기 때문

@DataJpaTest 사용.

@Import : 특정 객체가 네트워크에 추가됐다는 것을 명확하게 표현함.

- 데이터베이스를 mocking 하지 않았음.
- Testcontainers 같은 라이브러리를 이용해서 필요한 데이터베이스를 도커 컨테이너에 띄워서 사용함(h2와 타 db의 테스트 결과가 다를수 있기 때문.)

시스템 테스트로 주요 경로 테스트
--
- @SpringBootTest, TestRestTemplate  사용.
- 가독성을 높이기 위해 헬퍼 메서드를 사용( 헬퍼 메서드 : 여러가지 상태를 검증할 때 사용할 수 있는 도메인 특화 언어(DSL))
- JGiven같은 행동 주도 개발을 위한 라이브러리는 테스트용 어휘를 만드는데 도움을 줌
- 계층 간 매핑 버그를 알 수 있음.

얼마만큼의 테스트가 충분할까
--
얼마나 마음 편하게 소프트웨어를 배포할 수 있느냐를 테스트의 성공 기준으로 삼음.
- 초기에는 믿음의 도약이 필요함. 버그를 수정하고 이로부터 배우는 것.
- 도메인 엔티티를 구현할 때는 단위 테스트로 커버
- 유스케이스를 구현할 때는 단위 테스트로 커버
- 어댑터는 통합테스트
- 사용자의 행동 및 경로는 시스템 테스트



