##### Intro
* 저자는 기술 부채를 쌓아가며 지름길의 유혹을 느끼는 것을 저주함.
* 기술 부채 : 기술적으로 해결되어야 할 문제들을 뒤로 미루고, 비즈니스 문제를 해결하는 시점을 당기는 것.
* 지름길을 방지하기 위해서 혹은 정당한 지름길을 판단하려면 지름길 자체를 파악해야 한다.

##### 왜 지름길은 깨진 창문 같을까?
> * 필립 짐바르도 "깨진 창문 이론"
>   * 기물 파손이 흔한 동네에서는 방치된 차를 도둑질하거나 망가뜨리는 일이 더 쉽게 일어난다.
>   * '좋은' 동네라도 차의 창문이 깨져있다면 차를 망가뜨리는 일이 쉽게 일어난다.
> * 코드 작업에 적용하면
>   * 품질이 떨어진 코드에서 작업할 때 더 낮은 품질의 코드를 추가하기가 쉽다.
>   * 코딩 규칙을 많이 어긴 코드에서 작업할 때 또 다른 규칙을 어기기도 쉽다.
>   * 지름길을 많이 사용한 코드애서 작업할 때 또 다른 지름길을 추가하기도 쉽다.
> * 코드 품질이 계속 떨어짐...

##### 깨끗한 상태로 시작할 책임
* 지름길을 쓰지 않고 기술 부채를 지지 않은 채로 프로젝트를 깨끗하게 시작하는 것이 중요.
* 지름길을 취하는 경우는 작업 중인 부분이 프로젝트 전체로 봤을 때 그리 중요하지 않거나, 경제적인 이유가 있을 수 있듬
  * 이런 '의도적인 지름길'에 대해서는 세심하게 잘 기록해야 함 
  * 마이클 나이가드의 아키텍처 결정 기록의 형태도 괜찮음

##### 유스케이스 간 모델 공유하기
* 유스케이스의 입력 파라미터의 타입과 반환값의 타입이 달라야 한다.
  * 유스케이스 간에 입출력 모델을 공유하게 되면 유스케이스들 사이에 결합이 생김
  * 공유하고 있는 클래스가 변경되면 해당 유스케이스들 모두 영향을 받는다.
  * 단일 책임 원칙에서 이야기하는 '변경할 이유'를 공유하는 것.
* 유스케이스 간에 입출력 모델을 공유하는 것은 유스케이스들이 기능적으로 묶여 있을 때 유효함.
  * 특정 세부사항을 변경할 경우 실제로 두 유스케이스 모두에 영향을 주고 싶은 것만
* 비슷한 개념의 유스케이스 여러 개를 만든다면 유스케이스를 독립적으로 진화할 필요가 있는지 주기적으로 질문해야
  * 대답이 "예"가 되는 그때가 바로 입출력 모델을 분리할 시점

##### 도메인 엔티티를 입출력 모델로 사용하기
* 간단한 생성이나 업데이트 유스케이스에서는 유스케이스 인터페이스에 도메인 엔티티가 있는 것이 괜찮을지도 모른다. 왜냐하면 상태 정보가 도메인 엔티티에 있기 때문.
* 그러나
* 유스케이스가 더 복잡한 도메인 로직을 구현해야 한다면(도메인 로직의 일부를 풍부한 도메인 엔티티로 위임할 수 있으니), 유스케이스 인터페이스에 대한 전용 입출력 모델을 만들어야 한다.
* 왜냐하면 유스케이스의 변경이 도메인 엔티티까지 전파되길 바라진 않을 것이기 때문.
* 보통 많은 유스케이스가 간단한 생성 또는 업데이트로 시작해서 복잡한 도메인 로직 괴물이 되어간다
* 위는 점점 복잡도를 높여가는 애자일 환경에서 특히 그렇다고 함.
* 따라서 처음에는 도메인 엔티티를 입력 모델로 사용했더라도 도메인 모델로부터 독립적인 전용 입력 모델로 교체해야 하는 시점을 잘 파악해야 한다.

##### 인커핑 포트 건너뛰기
* 아웃고잉 포트 : 애플리케이션 계층과 아웃고잉 어댑터 사이의 의존성을 역전시키기 위한 필수 요소
* 인커밍 포트 : 의존성역전에 필수적인 요소는 아님. 인커핑 어댑터가 인커핑 포트 없이 직접 애플리케이션 서비스에 접근할 수 있음
* 그러나
1. 인커밍 포트는 애플리케이션 중심에 접근하는 진입점을 정의
   * 특정 유스케이스를 구현하기 위해 어떤 서비스 메서드를 호출해야 할지 한눈에 진입점이 보임.
2. 아키텍처를 쉽게 강제할 수 있음
   * 강제하는 옵션을 이용하면 인커밍 어댑터가 애플리케이션 서비스가 아닌 인커밍 포트만 호출하게 할 수 있음. 
* 애플리케이션의 규모가 점차 커지면 건너뛰는 것은 지양해야 할듯

##### 애플리케이션 서비스 건너뛰기
* 애플리케이션 서비스를 건너띈다면
  * 인커밍 포트를 직접 아웃고잉 어댑터가 구현하는 상황이 발생
    * 인커밍 어댑터와 아웃고잉 어댑터 사이에 모델을 공유
    * 그 모델이 도메인 엔티티...
    * 애플리케이션 코어에 유스케이스라고 할 만한 것이 없어지게 되고, 도메인 로직은 아웃고잉 어댑터에 추가하고 싶은 생각이 들 것 -> 유지보수가 어려워짐
  * 즉, 단순히 전달만 하는 보일러플레이트 코드를 방지하기 위해 애플리케이션 서비스를 건너띌수는 있으나
  * 유스케이스가 더 복잡한 일을 하게 되면 애플리케이션 서비스를 만든하는 명확한 가이드라인을 팀에 정해둬야 함.
  
##### 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
* 모든 애플리케이션은 처음에는 작게 시작하기에 유스케이스가 단순한 CRUD 상태에서 벗어나는 시점이 언제인지에 대해 팀이 합의하는 것이 매우 중요함.
* CRUD 상태에서 벗어나지 않는 유스테이스는 건너띄는 것이 경제적
* 지름길을 왜 선택했는지에 대한 기록을 남겨, 프로젝트를 인계받는 이들이 이 결정에 대해 다시 평가할 수 있게 하자.
