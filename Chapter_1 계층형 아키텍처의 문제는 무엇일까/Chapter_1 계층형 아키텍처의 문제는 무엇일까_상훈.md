### Intro
* 계층형 아키텍처 : 웹 -> 도메인 > 영속성
* 장점
  > 웹, 영속성 계층에 독립적으로 도메인 로직을 작성할 수 있다.
  * 변화하는 요구사항과 외부 요인에 빠르게 적응할 수 있게 해준다. 그래서 견고하다
* 문제점
  * 나쁜습관, 유지 보수에 어려움
##### 계층형 아키텍쳐는 데이터베이스 주도 설계를 유도한다
> 애플리케이션의 목적 : 비즈니스를 관장하는 규칙이나 정책을 반영한 모델을 만들어서 사용자가 이러한 규칙과 정책을 더욱 편리하게 활용할 수 있게 한다.
> * 우리는 여기서 '행동'을 중심으로 모델링을 한다.
> * 행동이 '상태'를 바꾸는 주체이기에 행동이 비즈니스를 이끌어 가기 때문.
> > 그렇다면 왜 `도메인 로직(행동)'이 아닌 `데이터베이스(상태)`를 토대로 아키텍처를 만드는 걸까?
> > ex. 유스케이스 영속성 계층을 먼저... 의존성의 방향에 따라 자연스럽지 않나?
###### 그렇다면 원인은?
* ORM
  * 영속성 코드가 사실상 도메인 코드에 녹아들어가서 영속석 계층과 도메인 계층 사이에 강한 결합이 생김
  * 결과적으로 유연하고 선택의 폭을 넓혀준다던 계층형 아키텍처의 목표와 정확히 반대.
##### 지름길을 택하기 쉬어진다 (나쁜습관)
> 상위 계층에 위치한 컴포넌트에 접근해야 한다면 간단하게 컴포넌트를 계층 아래로 내려버리면 된다.
> * 영속성 계층에서는 모든 것에 접근 가능하기 때문에 시간이 지나면서 점점 비대해지게 됨
###### 대책은?
* 위의 '지름길 모드'는 추가적인 아키텍처 규칙을 강제하지 않는 한 계층은 최선의 선택이 아니다
* '강제한다' : 해당 규칙이 깨졌을때 빌드가 실패하도록 만드는 규칙을 의미
##### 테스트하기 어려워진다
1. 단 하나의 필드를 조작하는 것에 불과하더라도 도메인 로직을 웹 계층에 구현하게 된다는 것.
   <br> -> 지속적으로 도메인 로직들이 퍼져나갈 확률이 높다.
2. 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 모킹해야 한다는 것.
   <br> => 단위 테스트의 복잡도가 올라간다. -> 테스트를 skip 하게 됨.
###### 종속성을 이해하고 목을 만드는데 어 많은 시간이 걸리게 된다.
##### 유스케이스를 숨긴다
> * 계층형 아키텍처에서는 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉽다.
> * 유스케이스가 '간단'해서 도메인 계층을 생략
>   * -> 기능을 추가하거나 변경할 적절한 위치 즉, 엔트리 포인트를 찾기가 어려워진 상태
> * 계층형 아키텍처는 도메인 서비스의 '너비' 에 관해 규칙을 강제하기 하지 않는다 -> 넓은 서비스가 만들어지기도 함
>> 고도로 특화된 좁은 도메인 서비스가 유스케이스 하나씩만 담당하게 한다면 이런 작업들이 얼마나 수월해질까?
> * UserService -> RegisterUserSerivce
##### 동시 작업이 어려워 진다
* 계층형 아키텍처의 구조상 분업이 어렵다
* 코드에 넓은 서비스가 있을 경우 서로 다른 기능을 동시에 작업하기는 더욱 어려움 -> 병합충돌과 잠재적으로 이전 코드로 되돌려야 하는 문제를 발생시킴
##### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?
* 엄격한 자기 관리 없이는 계층형 아키텍처의 유지보수는 힘들다. 품질 저하