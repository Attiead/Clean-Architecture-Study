##### Intro
* 육각형 아키텍처에서 웹, 영속성계층, 애플리케이션 계층이 아주 느슨하게 결합 -> 필요한 대로 도메인 코드를 자유롭게 모델링 가능
* DDD, 풍부하거나(rich) 빈약한(anemic) 도메인 모델등
##### 도메인 모델 구현하기

##### 유스케이스 둘러보기
순서|유스케이스 단계|위치
:---:|---|---
1|입력을 받는다|인커밍 어댑터
2|비즈니스 규칙을 검증한다.|
3|모델 상태를 조작한다.|
3|출력을 반환한다.|아웃고잉 어댑터

* 저자는 유스케이스 코드가 도메인 로직에만 신경 써야하고 입력 유효성 검증으로 오염되면 안 된다고 생각함.
* 입력 유효성 검증과 비즈니스 규칙 검증의 차이점은 후술

##### 입력 유효성 검증
* 애플리케이션 계층에서 입력 유효성을 검증해야 하는 이유는 그렇게 하지 않을 경우 애플리케이션 코어의 바깥쪽으로부터 유효하지 않은 입력값을 받게 되고, 모델의 상태를 해칠 수 있기 때문
* 유스케이스 클래스가 아니라면 도대체 어디에서 입력 유효성을 검증해야 할까?

##### 생성자의 힘

##### 유스케이스마다 다른 입력 모델

##### 비즈니스 규칙 검증하기
> 언제 입력 유효성을 검증하고 언제 비즈니스 규칙을 검증해야 할까?
> * 입력 유효성을 검증하는 것은 구문상의 유효성을 검증하는 것이라고 할 수 있다.... 예?
> * 비즈니스 규칙은 유스케이스의 맥락 속에서 의미적인 유효성을 검증하는 일이라고 할 수 있다... 예?
##### 풍부한 도메인 모델 VS 빈약한 도메인 모델
* 풍부한 도메인 모델
  * 애플리케이션의 코어에 있는 엔티티에서 가능한 한 많은 도메인 로직이 구현
  * 엔티티들은 상태를 변경하는 메서드를 제공하고, 비즈니스 규칙에 맞는 유효한 변경만을 허용
* 빈약한 도메인 모델
  * 엔티티 자체가 굉장히 얇음
  * 도메인 로직이 유스케이스 클래스에 구현되어 있음
  * 비즈니스 규칙 검증, 엔티티의 상태를 변경, 데이터베이스 저장을 담당하는 아웃고잉 포트에 엔티티를 전달할 책임 모두 유스케이스에 있음
  * 즉, '풍부함'이 엔티티가 아닌 유스케이스에 있다.
##### 유스케이스마다 다른 출력 모델

##### 읽기 전용 유스케이스는 어떨까?
> UI에 계좌의 잔액을 표시하기
* 새로운 유스케이스를 구현하기 보다는 
* 애플리케이션 코어의 관점에서 이 작업은 간단한 데이터 쿼리이기 때문에 
* 전체 프로젝트 맥락에서 유스케이스로 간주되지 않는다면 실제 유스케이스 구분하기 위해 쿼리로 구현ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅑ

##### 유지 보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?
* 유스케이스별로 모델을 만들면...
  * 유스케이스를 명확히 이해할 수 있고..
  * 여러 명의 개발자가 다른 사람의 작업 중인 유스케이스를 건드리지 않은 채로 여러 개의 유스케이스를 동시에 작업 가능..
* 꼼꼼한 입력 유효성 검증 + 유스케이스별 입출력 모델 = 지속 가능한 코드를 만드는데 큰 도움이 되므ㅑㅑㅑㅑㅑㅑㅑㅑㅑㅑㅑㅑㅑㅑㅑㅑㅑㅑㅑㅑㅑㅑㅑㅑ