##### Intro
* 새 프로젝트에서 가장 먼저 제대로 만들려고 하는 것은 `패키지 구조`
* 그러나 프로젝트가 진행될수록 엉망진창, 불어오지 말아야 할 다른 패키지에 있는 클래스들을 불러오게 됨
##### 계층으로 구성하기
* 웹 - 도메인 - 영속성
* 의존성 역전 원칙을 적용 
  * domain 패키지에 AcoountRepository 인터페이스 추가
  * persistence 패키지에 AccountRepositoryImpl 구현체 추가
###### 그러나
* 위 패키지 구조는 최적의 구조가 아님
  * 애플리케이션의 기능 조각이나 특성을 구분 짓는 패키지 경계가 없다. -> 추가적인 구조가 없으면 엉망진창 됨
  * 애플리케이션이 어떤 유스케이스들을 제공하는지 파악할 수 없다. -> 특정 기능을 찾기 위해서는 어떤 서비스가 이를 구현했는지 추측해야 하는 상황이 됨
  * 패키지 구조를 통해서는 우리가 목표로 하는 아키텍처를 파악할 수 없다.
    * 어떤 기능이 웹 어댑터에서 호출되는지, 영속성 어댑터가 도메인 계층에 어떤 기능을 제공하는지 한 눈에 알아볼수 없다. (흐름을 알기 힘들다)
##### 기능으로 구성하기
> account - Account, AcoountController, AcoountRepository.....
* package-private 접근 수준을 이용해 경계를 패키지 경게를 강화하여 각 기능(account, order...) 사이의 불필요한 의존성을 방지할 수 있다.
  * package-private?
    * defalut 접근제어자
    * 같은 패키지에 있는 다른 클래스까지 접근을 허용
* 추가로 'AccountServie'의 책임을 좁히기 위해 'SendMoneyServie'로 클래스명을 바꾸면, 바뀐 클래스명만으로도 해당 기능 유스케이스를 구현한 코드를 찾을 수 있게 됨
  * cf. 로버트마틴 '소리치는 아키텍처' , 코드가 그 의도를 우리에게 소리치고 있기 때문에
###### 그러나
* 기능 기준 패키징 방식은 이전의 계층 기준 패키징보다 아키텍처 가시성을 훨씬 더 떨어뜨림.
  * 클래스명 네이밍 + 인터페이스 -> 의존성을 역전 시켜도... private-default 접근 수준을 이용해 도메인 코드가 실수로 영속성 코드에 의존하는 것을 막을 수 없다.
###### 한눈에 파악하기 쉬운 아키텍처는 어떻게 만들 수 있을까?
* 육각형 아키텍처
##### 아키텍처적으로 표현력 있는 패키지 구조
* 육각형 아키텍처의 핵심 요소 : 엔티티, 유스케이스, 인커밍/아웃고잉 포트, 인커밍/아웃고잉 어댑터
> p. 27) 그림 3.3 
> * account // Account와 관련된 유스케이스를 구현한 모듈
>   * `adapter` 
>     * `in` // 애플리케이션 계층의 인커핑 포트를 호출하는 인커밍 어댑터
>       * `web`
>         * AccountController
>     * `out` // 애플리케이션 계층의 아웃고잉 포트에 대한 구현을 제공하는 아웃고잉 어댑터
>       * `persistence`
>         * AccountPersistence
>         * SpringDataAccontRepository
>   * `domain` // 도메인 모델
>     * Account
>     * Activity
>   * `application` // 도메인을 둘러싼 서비스 계층 포함
>     * SendMoneyService // SendMoneyService 구현, LoadAccountPort, UpdateAccountStatePort 사용
>     * `port`
>       * `in`
>         * SendMoneyUseCase // 인커밍 포트 인터페이스
>       * `out`
>         * LoadAccountPort // 아웃고잉 포트 인터페이스, 영속성 어댑터에 의해 구현됨
>         * UpdateAccountStatePort
* 위 패키지 구조 장점
  1. 위 패키지 구조는 이른바 '아키텍처-코드 갭(architecture-code gap)' 혹은 '모델-코드 갭(model-code gap'을 효과적으로 다룰수 있는 요소다.
  2. 아키텍처가 코드에 직접적으로 매핑될 수 없는 추상적인 개념이라는 사실을 보여준다.
     * Q. 추상적이기에 표현력 있는 패키지 구조이다?
  3. 표현력 있는 패키지 구조는 아키텍처에 대한 적극적인 사고를 촉진한다. -> 현재 작업중인 코드를 어떤 패키지에 넣어야 할지 계속 생각해야하기 때문.
> 패키지가 많아 -> public으로 패키지 간의 접근을 허용해야한다는 의미일까?(저자)
  >* 적어도 어댑터 패키지에 대해서는 그렇지 않다.
  >  * 이 패키지에 들어 있는 모든 클래스들은 application 패키지 내에 있는 포트 인터페이스를 통하지 않고는 바깥에서 호출되지 않기 때문 -> package-private 접근 수준으로 해도 됨.
  >  * (그러나) application 패키지와 domain 패키지 내의 일부 클래스들은 public으로 지정해야 한다.
  >    * application : 어댑터에서 접근 가능해야 하는 포트들 
  >    * domain 
  >      * 도메인 클래스 : 서비스 및 어댑터에서 접근 가능하도록 public으로 열어야
  >      * 서비스 : 인커밍 포트 인터페이스 뒤에 숨겨질 수 있기 때문에 public일 필요가 없다.
  4. Q. 어댑터 코드를 자체 패키지로 이동시키면 필요할 경우 하나의 어댑터를 다른 구현으로 쉽게 교체할 수 있다?
    * 예를 들면?
  5. DDD 개념에 직접적으로 대응 가능하다.
    * account (상위 레벨)패키지는 다른 바운디드 컨텍스트와 통신할 전용 진입점 + 출구(포트)를 포함하는 바운디드 컨텍스트에 해당
##### 의존성 주입의 역할
> 클린 아키텍처의 가장 본질적인 요건 : 애플리케이션 계층이 인커밍/아웃고잉 어댑터에 의존성을 갖지 않는 것.

##### 유지보수가 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?
* 육각형 아키텍처 패키지 구조
* 코드에서 아키텍처의 특정요소를 찾으려면 이제 아키텍처 다이어그램의 박스 이름을 따라 패키지 구조를 탐색하면 됨