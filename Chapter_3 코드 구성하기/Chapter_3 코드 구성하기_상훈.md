##### Intro
* 새 프로젝트에서 가장 먼저 제대로 만들려고 하는 것은 `패키지 구조`
* 그러나 프로젝트가 진행될수록 엉망진창, 불어오지 말아야 할 다른 패키지에 있는 클래스들을 불러오게 됨
##### 계층으로 구성하기
* 웹 - 도메인 - 영속성
* 의존성 역전 원칙을 적용 
  * domain 패키지에 AcoountRepository 인터페이스 추가
  * persistence 패키지에 AccountRepositoryImpl 구현체 추가
###### 그러나
* 위 패키지 구조는 최적의 구조가 아님
  * 애플리케이션의 기능 조각이나 특성을 구분 짓는 패키지 경계가 없다. -> 추가적인 구조가 없으면 엉망진창 됨
  * 애플리케이션이 어떤 유스케이스들을 제공하는지 파악할 수 없다. -> 특정 기능을 찾기 위해서는 어떤 서비스가 이를 구현했는지 추측해야 하는 상황이 됨
  * 패키지 구조를 통해서는 우리가 목표로 하는 아키텍처를 파악할 수 없다.
    * 어떤 기능이 웹 어댑터에서 호출되는지, 영속성 어댑터가 도메인 계층에 어떤 기능을 제공하는지 한 눈에 알아볼수 없다. (흐름을 알기 힘들다)
##### 기능으로 구성하기
> account - Account, AcoountController, AcoountRepository.....
* package-private 접근 수준을 이용해 경계를 패키지 경게를 강화하여 각 기능(account, order...) 사이의 불필요한 의존성을 방지할 수 있다.
  * package-private?
    * defalut 접근제어자
    * 같은 패키지에 있는 다른 클래스까지 접근을 허용
* 추가로 'AccountServie'의 책임을 좁히기 위해 'SendMoneyServie'로 클래스명을 바꾸면, 바뀐 클래스명만으로도 해당 기능 유스케이스를 구현한 코드를 찾을 수 있게 됨
  * cf. 로버트마틴 '소리치는 아키텍처' , 코드가 그 의도를 우리에게 소리치고 있기 때문에
###### 그러나
* 기능 기준 패키징 방식은 이전의 계층 기준 패키징보다 아키텍처 가시성을 훨씬 더 떨어뜨림.
  * 클래스명 네이밍 + 인터페이스 -> 의존성을 역전 시켜도... private-default 접근 수준을 이용해 도메인 코드가 실수로 영속성 코드에 의존하는 것을 막을 수 없다.
###### 한눈에 파악하기 쉬운 아키텍처는 어떻게 만들 수 있을까?
* 육각형 아키텍처
##### 아키텍처적으로 표현력 있는 패키지 구조
* 육각형 아키텍처의 핵심 요소 : 엔티티, 유스케이스, 인커밍/아웃고잉 포트, 인커밍/아웃고잉 어댑터