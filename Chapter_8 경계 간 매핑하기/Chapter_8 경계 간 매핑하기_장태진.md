경계간 매핑하기
==

매핑하지 않기 전략
--
도메인과 애플리케이션 계층은 웹이나 영속성과 관련된 특수한 요구사항에 관심이 없음에도 불구하고 도메인 모델 클래스는 모든 요구사항을 다뤄야함.
-> 단일 책임 원칙을 위배함.

간단한 CRUD 유스케이스는 매핑하지 않기 전략이 필요할 때도 있다.<br>
-> 모든 계층이 정확히 같은 구조의, 정확히 같은 정보를 필요로 한다면.

많은 유스케이스들이 간단한 CRUD 유스케이스로 시작했다가 시간이 지남에 따라 값비싼 매핑전략이 필요하고, 풍부한 행동과 유효성 검증을 가진 제대로 된 
비즈니스 유스케이스로 바뀌어갔음.

양방향 매핑 전략
--
웹 계층에서는 웹 모델을 인커밍 포트 -> 도메인 모델로 매핑, 인커밍 포트에 의해 반환된 도메인 객체 -> 웹 모델로 매핑.

영속성 계층에서는 아웃고잉 포트가 사용하는 도메인 모델 -> 영속성 모델 간의 매핑.

각 계층이 전용 모델을 변경하더라도 다른 계층에 영향이 없음.

웹모델은 데이터를 최적으로 표현할 수 있는 구조를 가질 수 있고, 도메인 모델은 유스케이스를 제일 잘 구현할 수 있는 구조를 가짐.<br>
영속성 모델은 데이터베이스에 객체를 저장하기 위해 ORM에서 필요로 하는 구조를 가짐.

- 단일 책임 원칙을 만족함!
- 책임이 명확함

단점 : <br>
- 많은 보일러플레이트 코드 -> 매핑 구현에 시간이 걸림
- 도메인 모델이 계층 경계를 넘어서 통신하는데 사용됨. 

완전 매핑 전략
--
각 연산마다 별도의 입출력 모델을 사용.

입력 포트의 입력 모델로 도메인 모델이 아닌 특화된 모델을 사용함.<br>
e.g) command, request 모델

한 계층을 여러 커맨드로 매핑하는 데는 하나의 웹 모델과 도메인 모델간의 매핑보다 더 많은 코드가 필요하다<br>
-> 유지보수에는 쉬움.

전역 매턴으로 추천하지는 않음. 

웹계층과 애플리케이션 계층 사이에서 상태 변경 유스케이스의 경계를 명확하게 할 때 가장 빛을 발함.<br>
애플리케이션 계층과 영속성 계층 사이에서는 매핑 오버헤드 때문에 사용하지 않는 것이 좋다. 

단방향 매핑 전략
--
모든 계층의 모델들이 같은 인터페이스를 구현함. 

관련 있는 특성(attribute)에 대한 getter메서드를 제공해서 도메인 모델의 상태를 캡슐화함.

도메인 모델 자체는 풍부한 행동을 구현할 수 있고, 애플리케이션 계층 내의 서비스에서 이러한 행동에 접근할 수 있다. 

도메인 객체를 바깥 계층으로 전달하고 시으면 매핑없이 할 수 있다. 왜냐면 인커핑/아웃고잉 포트가 기대하는 대로 상태 인터페이스를 구현하고 있기 때문.

행동을 변경하는 것이 상태 인터페이스에 의해 노출돼 있지 않기 때문에 실수로 도메인 객체의 상태를 변경하는 일은 발생하지 않음.

이 매핑은 factory라는 DDD개념과 잘 어울린다. -> factory는 어떤 특정한 상태로부터 도메인 객체를 재구성할 책임을 가지는 것. 

장점 :<br>
- 매핑 책임이 명확함 

단점 : <br>
- 개념적으로 어려움.

매핑전략 
--
간단한 전략으로 시작해서 계층 간 결합을 떼어내는데 도움이 되는 복잡한 전략으로 갈아타는 것도 괜찮은 방법임.

팀 내에 가이드라인은 정해둬야함.<br>
e.g) 계층간 매핑전략

유지보수에는?
--
특정 상황, 특정 시점에 최선의 전략을 적용해서 사용해라! 그리고 가이드라인이 명확하다면 좋다.

