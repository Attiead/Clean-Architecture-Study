영속성 어댑터 구현하기
==

영속성 계층을 애플리케이션 계층의 플러그인으로 만드는 방법

의존성 역전
--
애플리케이션 서비스가 영속성 기능 사용을 위해 '포트 인터페이스를 호출함' -> 영속성 어댑터 클래스에 의해 구현됨.

영속성은 '아웃고잉' 어댑터!<br>
-> 호출을 당할 뿐! 호출을 하지는 않는다. -> 누가 플러그를 꽂아줘야만 동작하고 안꽂히면 무쓸모. 그치만 꽂혔을 때 동작할 설계는 스스로 했음.

영속성 어댑터의 책임
--
1. 입력을 받는다
2. 입력을 데이터베이스 포맷으로 매핑한다.
3. 입력을 데이터베이스로 보낸다
4. 데이터베이스 출력을 애플리케이션 포맷으로 매핑한다.
5. 출력을 반환한다.

여기서 영속성 어댑터는 데이터베이스 변경하는데 사용할 수 있는 입력 모델을 매핑하는데 이것이 JPA의 엔티티 객체로 매핑할 것이다.<br>
-> 물론 JPA 엔티티가 아닌 SQL 구문과 매핑해서 데이터베이스에 보내도 된다.

핵심은 영속성 어댑터의 입력 모델이 어댑터 내부에 있는게 아니라, 애플리케이션 코어에 있음.<br>
-> 영속성 어댑터 내부를 변경해도 코어에 영향을 끼치지 않음.<br>
-> 데이터베이스 응답을 포트에 정의된 출력 모델로 매핑해서 반환한다.

포트인터페이스 나누기
--
필요 없는 화물을 운반하는 무언가에 의존하고 있으면 예상하지 못했던 문제가 생길 수 있다.

2개의 서비스가 하나의 Repository 인터페이스를 사용하게 된다면 해당 인터페이스는 '넓은' 포트 인터페이스가 된다.<br>
즉, 필요하지 않은 메서드가 담겨 있는 인터페이스를 서비스가 가지고 있는 그림이 되버림.<br>
-> 특화된 인터페이스로 분리하자.

<그림 6.3>

서비스 코드를 짤 때는 필요한 포트(메서드)에 그저 '꽂기만' 하면 된다. 

영속성 어댑터 나누기
--
<그림 6.4>

도메인 클래스(애그리거트) 하나당 하나의 영속성 어댑터를 구현하는 방식을 사용하면 자연스럽게 영속성 어댑터를 나눌 수 있다.

JPA 어댑터 1개, SQL 어댑터 1개 등으로도 구현 가능!

바운디드 컨텍스트 간의 경계를 명확하게 구분하고 싶다면 바운디드 컨텍스트가 영속성 어댑터들을 하나씩 가지고 있어야 한다.<br>
-> 서로 접근하지 않는 가정일때

트랜잭션
--
영속성 어댑터 호출을 관장하는 서비스에 위힘해야함.<br>
-> 서비스 클래스에 @Transactional을 붙임.<br>
-> aop에 위임해도 됨.

유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
--
도메인 코드에 플러그인 처럼 동작하는 영속성 어댑터를 만들면 도메인 코드가 영속성과 관련된 것들로부터 분리되어 풍부한 도메인 도멜을 만들 수 있음.

좁은 포트 인터페이스를 사용하면 포트마다 다른 방식이 때문에 유연해짐.<br>
포트 뒤에서 다른 기술을 사용해도 됨.

포트의 명세가 지켜진다면 영속성(DB 연관)을 교체도 가능함.






